//! `parse_tests.rs` is generated by build.rs
#[test]
/// unescaped angle bracket in an attribute value
fn bad_syntax_angle_in_attribute_value_test() {
    let info = xtest::load("angle-in-attribute-value");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    assert!(parse_result.is_err());
    let err = parse_result.err().unwrap();
    match err {
        exile::error::Error::Parse(parse_error) => {
            assert_eq!(51, parse_error.xml_site.position);
            assert_eq!(2, parse_error.xml_site.line);
            assert_eq!(12, parse_error.xml_site.column);
        }
        _ => panic!("Error was expected to be of type exile::error::Error::Parse, but was not."),
    }
}

#[test]
/// cd_catalog example from https://www.w3schools.com/xml/xml_examples.asp
fn good_syntax_cd_catalog_test() {
    let info = xtest::load("cd_catalog");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
    let got_doc = parse_result.as_ref().unwrap();
    let want_doc = info.metadata.expected.as_ref().unwrap();
    let equal = want_doc == got_doc;
    if !equal {
        let want = want_doc.to_string();
        let got = got_doc.to_string();
        if want != got {
            assert_eq!(got, want);
        } else {
            assert!(equal);
        }
    }
    let wanted_serialization = info.read_expected_write().unwrap();
    assert_eq!(got_doc.to_string(), wanted_serialization);
}

#[test]
/// a file with doctypes, processing instructions and comments
fn good_syntax_doctypes_comments_pis_test() {
    let info = xtest::load("doctypes-comments-pis");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
}

#[test]
/// escape sequences
fn good_syntax_escapes_test() {
    let info = xtest::load("escapes");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
    let got_doc = parse_result.as_ref().unwrap();
    let want_doc = info.metadata.expected.as_ref().unwrap();
    let equal = want_doc == got_doc;
    if !equal {
        let want = want_doc.to_string();
        let got = got_doc.to_string();
        if want != got {
            assert_eq!(got, want);
        } else {
            assert!(equal);
        }
    }
    let wanted_serialization = info.read_expected_write().unwrap();
    assert_eq!(got_doc.to_string(), wanted_serialization);
}

#[test]
/// a simple, small, well-formed xml file
fn good_syntax_ezfile_test() {
    let info = xtest::load("ezfile");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
    let got_doc = parse_result.as_ref().unwrap();
    let want_doc = info.metadata.expected.as_ref().unwrap();
    let equal = want_doc == got_doc;
    if !equal {
        let want = want_doc.to_string();
        let got = got_doc.to_string();
        if want != got {
            assert_eq!(got, want);
        } else {
            assert!(equal);
        }
    }
    let wanted_serialization = info.read_expected_write().unwrap();
    assert_eq!(got_doc.to_string(), wanted_serialization);
}

#[test]
/// a simple file with processing instructions
fn good_syntax_pi_test() {
    let info = xtest::load("pi");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
    let got_doc = parse_result.as_ref().unwrap();
    let want_doc = info.metadata.expected.as_ref().unwrap();
    let equal = want_doc == got_doc;
    if !equal {
        let want = want_doc.to_string();
        let got = got_doc.to_string();
        if want != got {
            assert_eq!(got, want);
        } else {
            assert!(equal);
        }
    }
}

#[test]
/// cd_catalog example from https://www.w3schools.com/xml/xml_examples.asp
fn good_syntax_simple_musicxml_test() {
    let info = xtest::load("simple_musicxml");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
    let got_doc = parse_result.as_ref().unwrap();
    let want_doc = info.metadata.expected.as_ref().unwrap();
    let equal = want_doc == got_doc;
    if !equal {
        let want = want_doc.to_string();
        let got = got_doc.to_string();
        if want != got {
            assert_eq!(got, want);
        } else {
            assert!(equal);
        }
    }
    let wanted_serialization = info.read_expected_write().unwrap();
    assert_eq!(got_doc.to_string(), wanted_serialization);
}

#[test]
/// unescaped angle bracket inside element text
fn bad_syntax_unescaped_angle_test() {
    let info = xtest::load("unescaped-angle");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    assert!(parse_result.is_err());
    let err = parse_result.err().unwrap();
    match err {
        exile::error::Error::Parse(parse_error) => {
            assert_eq!(95, parse_error.xml_site.position);
            assert_eq!(4, parse_error.xml_site.line);
            assert_eq!(39, parse_error.xml_site.column);
        }
        _ => panic!("Error was expected to be of type exile::error::Error::Parse, but was not."),
    }
}
