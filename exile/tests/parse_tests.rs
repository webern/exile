//! `parse_tests.rs` is generated by build.rs
#[test]
fn bad_syntax_unescaped_angle_test() {
    let info = xtest::load("unescaped-angle");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    assert!(parse_result.is_err());
    let err = parse_result.err().unwrap();
    match err {
        exile::error::Error::Parse(parse_error) => {
            assert_eq!(95, parse_error.xml_site.position);
            assert_eq!(4, parse_error.xml_site.line);
            assert_eq!(39, parse_error.xml_site.column);
        }
        _ => panic!("Error was expected to be of type exile::error::Error::Parse, but was not."),
    }
}

#[test]
fn good_syntax_escapes_test() {
    let info = xtest::load("escapes");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
    let actual = parse_result.as_ref().unwrap();
    let expected = info.metadata.expected.as_ref().unwrap();
    let equal = expected == actual;
    if !equal {
        let expected_str = expected.to_string();
        let actual_str = actual.to_string();
        if expected_str != actual_str {
            assert_eq!(expected_str, actual_str);
        } else {
            assert!(equal);
        }
    }
    let expected_serialization = info.read_expected_write().unwrap();
    assert_eq!(expected_serialization, actual.to_string());
}

#[test]
fn good_syntax_cd_catalog_test() {
    let info = xtest::load("cd_catalog");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
    let actual = parse_result.as_ref().unwrap();
    let expected = info.metadata.expected.as_ref().unwrap();
    let equal = expected == actual;
    if !equal {
        let expected_str = expected.to_string();
        let actual_str = actual.to_string();
        if expected_str != actual_str {
            assert_eq!(expected_str, actual_str);
        } else {
            assert!(equal);
        }
    }
    let expected_serialization = info.read_expected_write().unwrap();
    assert_eq!(expected_serialization, actual.to_string());
}

#[test]
fn bad_syntax_angle_in_attribute_value_test() {
    let info = xtest::load("angle-in-attribute-value");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    assert!(parse_result.is_err());
    let err = parse_result.err().unwrap();
    match err {
        exile::error::Error::Parse(parse_error) => {
            assert_eq!(51, parse_error.xml_site.position);
            assert_eq!(2, parse_error.xml_site.line);
            assert_eq!(12, parse_error.xml_site.column);
        }
        _ => panic!("Error was expected to be of type exile::error::Error::Parse, but was not."),
    }
}

#[test]
fn good_syntax_pi_test() {
    let info = xtest::load("pi");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
    let actual = parse_result.as_ref().unwrap();
    let expected = info.metadata.expected.as_ref().unwrap();
    let equal = expected == actual;
    if !equal {
        let expected_str = expected.to_string();
        let actual_str = actual.to_string();
        if expected_str != actual_str {
            assert_eq!(expected_str, actual_str);
        } else {
            assert!(equal);
        }
    }
}

#[test]
fn good_syntax_ezfile_test() {
    let info = xtest::load("ezfile");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
    let actual = parse_result.as_ref().unwrap();
    let expected = info.metadata.expected.as_ref().unwrap();
    let equal = expected == actual;
    if !equal {
        let expected_str = expected.to_string();
        let actual_str = actual.to_string();
        if expected_str != actual_str {
            assert_eq!(expected_str, actual_str);
        } else {
            assert!(equal);
        }
    }
    let expected_serialization = info.read_expected_write().unwrap();
    assert_eq!(expected_serialization, actual.to_string());
}

#[test]
fn good_syntax_doctypes_comments_pis_test() {
    let info = xtest::load("doctypes-comments-pis");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
}

#[test]
fn good_syntax_simple_musicxml_test() {
    let info = xtest::load("simple_musicxml");
    let xml_str = info.read_xml_file();
    let parse_result = exile::parse(xml_str.as_str());
    if let Err(e) = parse_result {
        panic!("expected parse_result to be Ok, got Err: {}", e);
    }
    let actual = parse_result.as_ref().unwrap();
    let expected = info.metadata.expected.as_ref().unwrap();
    let equal = expected == actual;
    if !equal {
        let expected_str = expected.to_string();
        let actual_str = actual.to_string();
        if expected_str != actual_str {
            assert_eq!(expected_str, actual_str);
        } else {
            assert!(equal);
        }
    }
    let expected_serialization = info.read_expected_write().unwrap();
    assert_eq!(expected_serialization, actual.to_string());
}
